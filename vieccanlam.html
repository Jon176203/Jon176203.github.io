<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Danh s√°ch vi·ªác c·∫ßn l√†m - T·ª•i m√¨nh</title>
    <meta
      name="description"
      content="Danh s√°ch vi·ªác c·∫ßn l√†m c√πng nhau c·ªßa Qu√¢n v√† Qu·ª≥nh"
    />
    <link rel="icon" type="image/svg+xml" href="assets/heart-favicon.svg" />
    <link rel="alternate icon" href="assets/heart-favicon.svg" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="floating-hearts" aria-hidden="true">
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
      <span></span>
    </div>
    <main class="love-card">
      <button class="page-back-button" id="pageBackButton" type="button" onclick="window.location.href='index.html'">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
        <span>Quay l·∫°i</span>
      </button>
      <div class="title" id="storyTitle">Danh s√°ch vi·ªác c·∫ßn l√†m</div>
      <p class="story-subtitle">C√πng nhau ho√†n th√†nh nh·ªØng vi·ªác nh·ªè xinh nh√©! üíï</p>
      
      <section class="todo-list-page" id="todoListPage">
        <div class="todo-list" id="todoList"></div>
      </section>
      
      <section class="todo-submit" id="todoSubmitSection">
        <h2 class="todo-submit__title">Th√™m vi·ªác c·∫ßn l√†m c√πng nhau</h2>
        <p class="todo-submit__hint">
          C√πng nhau ho√†n th√†nh nh·ªØng vi·ªác nh·ªè xinh nh√©! üíï
        </p>
        <form class="todo-form" id="todoForm" novalidate>
          <label class="todo-form__field">
            <span>N·ªôi dung vi·ªác c·∫ßn l√†m *</span>
            <input
              type="text"
              name="todoText"
              id="todoTextInput"
              maxlength="200"
              required
              placeholder="V√≠ d·ª•: ƒêi xem phim c√πng nhau"
            />
          </label>
          <button class="todo-form__submit button-with-feedback" id="todoSubmitButton" type="submit">
            ·∫§n ƒë√¢y ƒë·ªÉ th√™m nha bae :3
          </button>
          <p class="todo-form__status" id="todoFormStatus" role="status" aria-live="polite"></p>
        </form>
      </section>
    </main>

    <!-- Modal x√°c nh·∫≠n m·∫≠t kh·∫©u khi x√≥a -->
    <div class="todo-delete-password-modal" id="todoDeletePasswordModal" hidden>
      <div class="todo-delete-password-modal__backdrop" data-delete-password-modal-close></div>
      <div class="todo-delete-password-modal__dialog">
        <button
          type="button"
          class="todo-delete-password-modal__close"
          data-delete-password-modal-close
          aria-label="ƒê√≥ng"
        >
          √ó
        </button>
        <h2 class="todo-delete-password-modal__title">X√°c nh·∫≠n x√≥a</h2>
        <p class="todo-delete-password-modal__hint">
          Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√°c nh·∫≠n x√≥a vi·ªác c·∫ßn l√†m n√†y
        </p>
        <form class="todo-delete-password-modal__form" id="todoDeletePasswordForm" novalidate>
          <label class="todo-delete-password-modal__field">
            <span>M·∫≠t kh·∫©u *</span>
            <input
              type="password"
              id="deletePasswordInput"
              required
              placeholder="Nh·∫≠p m·∫≠t kh·∫©u"
              autocomplete="off"
            />
          </label>
          <p class="todo-delete-password-modal__status" id="deletePasswordStatus" role="status" aria-live="polite"></p>
          <div class="todo-delete-password-modal__buttons">
            <button
              type="button"
              class="todo-delete-password-modal__cancel"
              data-delete-password-modal-close
            >
              H·ªßy
            </button>
            <button
              type="submit"
              class="todo-delete-password-modal__submit"
              id="deletePasswordSubmitButton"
            >
              X√°c nh·∫≠n x√≥a
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Modal x√°c nh·∫≠n b·ªè tick -->
    <div class="todo-uncomplete-modal" id="todoUncompleteModal" hidden>
      <div class="todo-uncomplete-modal__backdrop" data-uncomplete-modal-close></div>
      <div class="todo-uncomplete-modal__dialog">
        <button
          type="button"
          class="todo-uncomplete-modal__close"
          data-uncomplete-modal-close
          aria-label="ƒê√≥ng"
        >
          √ó
        </button>
        <h2 class="todo-uncomplete-modal__title">X√°c nh·∫≠n</h2>
        <p class="todo-uncomplete-modal__hint">
          Em c√≥ ch·∫Øc l√† b·ªè tick n√†y hong?
        </p>
        <div class="todo-uncomplete-modal__buttons">
          <button
            type="button"
            class="todo-uncomplete-modal__cancel"
            data-uncomplete-modal-close
          >
            H·ªßy
          </button>
          <button
            type="button"
            class="todo-uncomplete-modal__submit button-with-feedback"
            id="uncompleteSubmitButton"
          >
            X√°c nh·∫≠n
          </button>
        </div>
      </div>
    </div>

    <!-- Modal ch·ªçn ng√†y gi·ªù ho√†n th√†nh -->
    <div class="todo-completion-modal" id="todoCompletionModal" hidden>
      <div class="todo-completion-modal__backdrop" data-completion-modal-close></div>
      <div class="todo-completion-modal__dialog">
        <button
          type="button"
          class="todo-completion-modal__close"
          data-completion-modal-close
          aria-label="ƒê√≥ng"
        >
          √ó
        </button>
        <h2 class="todo-completion-modal__title">Ch·ªçn ng√†y v√† gi·ªù ho√†n th√†nh</h2>
        <form class="todo-completion-modal__form" id="todoCompletionForm" novalidate>
          <label class="todo-completion-modal__field">
            <span>Ng√†y ho√†n th√†nh *</span>
            <input
              type="date"
              id="completionDateInput"
              required
            />
          </label>
          <label class="todo-completion-modal__field">
            <span>Gi·ªù ho√†n th√†nh *</span>
            <input
              type="time"
              id="completionTimeInput"
              required
            />
          </label>
          <div class="todo-completion-modal__buttons">
            <button
              type="button"
              class="todo-completion-modal__cancel"
              data-completion-modal-close
            >
              H·ªßy
            </button>
            <button
              type="submit"
              class="todo-completion-modal__submit button-with-feedback"
              id="completionSubmitButton"
            >
              X√°c nh·∫≠n
            </button>
          </div>
        </form>
      </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore-compat.js"></script>
    <script src="firebase-config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
    <script>
      const TODO_COLLECTION = "todos";
      const TIMELINE_FORM_PASSWORD = "tuilavoquan";

      let firestore = null;
      let todoUnsubscribe = null;
      let timelineFormUnlocked = false;
      let isFirebaseReady = false;
      let currentTodoIdForCompletion = null;
      let currentTodoIdForDelete = null;
      let currentTodos = [];
      let todoSortableInstance = null;
      let isHandlingTodoReorder = false;
      let currentTodoIdForUncomplete = null;

      function escapeHtml(value = "") {
        return value
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function openUncompleteModal(todoId) {
        const modal = document.getElementById("todoUncompleteModal");
        if (!modal) {
          return;
        }
        currentTodoIdForUncomplete = todoId;
        modal.hidden = false;
        document.body.classList.add("todo-uncomplete-modal-open");
        const confirmBtn = document.getElementById("uncompleteSubmitButton");
        if (confirmBtn) {
          confirmBtn.focus();
        }
      }

      function closeUncompleteModal() {
        const modal = document.getElementById("todoUncompleteModal");
        if (!modal) {
          return;
        }
        modal.hidden = true;
        document.body.classList.remove("todo-uncomplete-modal-open");
        const confirmBtn = document.getElementById("uncompleteSubmitButton");
        if (confirmBtn) {
          setButtonLoading(confirmBtn, false);
        }
        currentTodoIdForUncomplete = null;
      }

      async function handleUncompleteConfirm() {
        if (!currentTodoIdForUncomplete || !firestore) {
          closeUncompleteModal();
          return;
        }
        const confirmBtn = document.getElementById("uncompleteSubmitButton");
        try {
          if (confirmBtn) {
            setButtonLoading(confirmBtn, true, "ƒêang c·∫≠p nh·∫≠t...");
          }
          await firestore.collection(TODO_COLLECTION).doc(currentTodoIdForUncomplete).update({
            completed: false,
            completedAt: null,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          });
          closeUncompleteModal();
        } catch (error) {
          console.error(error);
          alert(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t: ${error?.message || String(error)}`);
          if (confirmBtn) {
            setButtonLoading(confirmBtn, false);
          }
        }
      }

      function escapeAttribute(value = "") {
        return escapeHtml(value);
      }

      function autoResizeTextarea(textarea) {
        if (!textarea) return;
        textarea.style.height = "auto";
        const scrollHeight = textarea.scrollHeight;
        const minHeight = 42;
        const maxHeight = 200;
        textarea.style.height = `${Math.min(Math.max(scrollHeight, minHeight), maxHeight)}px`;
        textarea.style.overflowY = scrollHeight > maxHeight ? "auto" : "hidden";
      }

      function formatDateTime(dateTime) {
        if (!dateTime) return "";
        const date = dateTime.toDate ? dateTime.toDate() : new Date(dateTime);
        const day = String(date.getDate()).padStart(2, "0");
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const year = date.getFullYear();
        const hours = String(date.getHours()).padStart(2, "0");
        const minutes = String(date.getMinutes()).padStart(2, "0");
        return `${day}/${month}/${year} ${hours}:${minutes}`;
      }

      function setButtonLoading(button, isLoading, loadingLabel = "ƒêang x·ª≠ l√Ω...") {
        if (!button) {
          return;
        }

        button.classList.add("button-with-feedback");

        if (isLoading) {
          if (!button.dataset.originalLabel) {
            button.dataset.originalLabel = button.textContent.trim();
          }

          if (!button.dataset.loadingPrevDisabled) {
            button.dataset.loadingPrevDisabled = button.disabled ? "true" : "false";
          }

          if (typeof loadingLabel === "string" && loadingLabel) {
            button.textContent = loadingLabel;
          }

          button.classList.add("is-loading");
          button.setAttribute("aria-busy", "true");
          button.disabled = true;
        } else {
          const originalLabel = button.dataset.originalLabel;

          if (typeof originalLabel === "string") {
            button.textContent = originalLabel;
          }

          button.classList.remove("is-loading");
          button.removeAttribute("aria-busy");

          const wasDisabled = button.dataset.loadingPrevDisabled === "true";
          if (!wasDisabled) {
            button.disabled = false;
          }

          delete button.dataset.loadingPrevDisabled;
        }
      }

      function attachButtonFeedback(button) {
        if (!button || button.dataset.buttonFeedbackBound === "true") {
          return;
        }

        button.dataset.buttonFeedbackBound = "true";
        button.classList.add("button-with-feedback");

        const removePressed = () => {
          if (button.classList.contains("ios-pressed")) {
            button.classList.remove("ios-pressed");
            // trigger spring-like release
            button.classList.add("ios-release");
            const cleanup = () => {
              button.classList.remove("ios-release");
              button.removeEventListener("animationend", cleanup);
            };
            button.addEventListener("animationend", cleanup);
          }
        };

        button.addEventListener("pointerdown", (event) => {
          if (button.disabled || button.classList.contains("is-loading")) {
            return;
          }
          button.classList.remove("ios-release");
          button.classList.add("ios-pressed");

          // Ripple
          const rect = button.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          const maxDim = Math.max(rect.width, rect.height);
          const rippleSize = maxDim * 1.35; // a bit larger than button

          const ripple = document.createElement("span");
          ripple.className = "button-ripple";
          ripple.style.left = `${x}px`;
          ripple.style.top = `${y}px`;
          ripple.style.setProperty("--ripple-size", `${rippleSize}px`);

          // Clean up any previous finished ripples
          const oldRipples = button.querySelectorAll(".button-ripple");
          oldRipples.forEach((r) => {
            if (r.getAnimations && r.getAnimations().length === 0) {
              r.remove();
            }
          });

          button.appendChild(ripple);

          ripple.addEventListener("animationend", () => {
            ripple.remove();
          });
        });

        ["pointerup", "pointerleave", "pointercancel"].forEach((eventName) => {
          button.addEventListener(eventName, removePressed);
        });

        button.addEventListener("blur", removePressed);

        button.addEventListener("keydown", (event) => {
          if ((event.code === "Space" || event.code === "Enter") && !button.disabled && !button.classList.contains("is-loading")) {
            button.classList.remove("ios-release");
            button.classList.add("ios-pressed");
          }
        });

        button.addEventListener("keyup", (event) => {
          if (event.code === "Space" || event.code === "Enter") {
            removePressed();
          }
        });
      }

      function getTodoOrderValue(todo = {}) {
        if (typeof todo.order === "number") {
          return todo.order;
        }

        const createdAt = todo.createdAt?.toMillis?.() || todo.createdAt || 0;
        return createdAt ? -createdAt : 0;
      }

      function sortTodosForDisplay(todos = []) {
        return todos
          .slice()
          .sort((a, b) => {
            if (a.completed !== b.completed) {
              return a.completed ? 1 : -1;
            }

            const orderA = getTodoOrderValue(a);
            const orderB = getTodoOrderValue(b);

            if (orderA !== orderB) {
              return orderA - orderB;
            }

            const timeA = a.createdAt?.toMillis?.() || a.createdAt || 0;
            const timeB = b.createdAt?.toMillis?.() || b.createdAt || 0;
            return timeB - timeA;
          });
      }

      function destroyTodoSortable() {
        if (todoSortableInstance) {
          todoSortableInstance.destroy();
          todoSortableInstance = null;
        }
      }

      function updateTodoSortableDisabled() {
        if (todoSortableInstance) {
          todoSortableInstance.option("disabled", !timelineFormUnlocked);
        }
      }

      function setupTodoSortable() {
        const todoListContainer = document.getElementById("todoList");
        if (!todoListContainer) {
          return;
        }

        const todoItems = todoListContainer.querySelectorAll(".todo-item");
        if (!todoItems.length) {
          destroyTodoSortable();
          return;
        }

        if (typeof Sortable === "undefined") {
          return;
        }

        destroyTodoSortable();

        todoSortableInstance = Sortable.create(todoListContainer, {
          animation: 150,
          handle: ".todo-item",
          draggable: ".todo-item",
          filter: "input,button",
          delay: 150,
          delayOnTouchOnly: true,
          touchStartThreshold: 4,
          forceFallback: true,
          fallbackTolerance: 3,
          disabled: !timelineFormUnlocked,
          onEnd: (event) => {
            if (event.oldIndex === event.newIndex) {
              return;
            }
            handleTodoReorder();
          },
        });

        updateTodoSortableDisabled();
      }

      async function handleTodoReorder() {
        if (!firestore || !timelineFormUnlocked || isHandlingTodoReorder) {
          return;
        }

        const todoListContainer = document.getElementById("todoList");
        if (!todoListContainer) {
          return;
        }

        const todoItems = Array.from(todoListContainer.querySelectorAll(".todo-item"));
        if (!todoItems.length) {
          return;
        }

        const orderMap = new Map(
          currentTodos.map((todo) => [
            todo.id,
            typeof todo.order === "number" ? todo.order : null,
          ])
        );

        const batch = firestore.batch();
        let hasChanges = false;
        let nextIncompleteOrder = 0;
        let nextCompletedOrder = 0;

        todoItems.forEach((item) => {
          const todoId = item.dataset.todoId;
          if (!todoId) {
            return;
          }

          const isCompleted = item.classList.contains("todo-item--completed");
          const nextOrder = isCompleted ? nextCompletedOrder++ : nextIncompleteOrder++;
          const previousOrder = orderMap.has(todoId) ? orderMap.get(todoId) : null;

          if (previousOrder !== nextOrder) {
            const docRef = firestore.collection(TODO_COLLECTION).doc(todoId);
            batch.update(docRef, {
              order: nextOrder,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
            });
            hasChanges = true;
          }
        });

        if (!hasChanges) {
          return;
        }

        isHandlingTodoReorder = true;

        try {
          await batch.commit();
        } catch (error) {
          console.error(error);
          alert(`Kh√¥ng th·ªÉ s·∫Øp x·∫øp l·∫°i: ${error?.message || String(error)}`);
        } finally {
          isHandlingTodoReorder = false;
        }
      }

      function createTodoItem(todo = {}) {
        const { id, text = "", completed = false, createdAt, completedAt } = todo;
        const safeId = id ? escapeAttribute(id) : "";
        const safeText = escapeHtml(text);
        const isCompleted = Boolean(completed);
        const canEdit = timelineFormUnlocked;
        const completedAtText = completedAt ? formatDateTime(completedAt) : "";

        return `
          <div class="todo-item ${isCompleted ? "todo-item--completed" : ""}" data-todo-id="${safeId}">
            <label class="todo-item__checkbox-wrapper">
              <input
                type="checkbox"
                class="todo-item__checkbox"
                ${isCompleted ? "checked" : ""}
                ${canEdit ? "" : "disabled"}
                data-todo-checkbox="${safeId}"
              />
              <span class="todo-item__checkmark"></span>
            </label>
            <div class="todo-item__content">
              <span class="todo-item__text">${safeText}</span>
              ${completedAtText ? `<span class="todo-item__completed-date">Ho√†n th√†nh: ${escapeHtml(completedAtText)}</span>` : ""}
            </div>
            ${canEdit ? `<button type="button" class="todo-item__delete" data-todo-delete="${safeId}" aria-label="X√≥a">√ó</button>` : ""}
          </div>
        `;
      }

      function renderTodoList(todos = []) {
        const todoListContainer = document.getElementById("todoList");
        if (!todoListContainer) return;

        currentTodos = Array.isArray(todos) ? todos.slice() : [];

        if (!Array.isArray(todos) || todos.length === 0) {
          destroyTodoSortable();
          todoListContainer.innerHTML =
            '<p class="todo-empty">Ch∆∞a c√≥ vi·ªác c·∫ßn l√†m n√†o ‚Äî c√πng nhau t·∫°o danh s√°ch nh√©! üíï</p>';
          return;
        }

        const sortedTodos = sortTodosForDisplay(todos);

        todoListContainer.innerHTML = sortedTodos.map(createTodoItem).join("");
        attachTodoHandlers();
        setupTodoSortable();
      }

      function renderTodoLoading() {
        const todoListContainer = document.getElementById("todoList");
        if (!todoListContainer) return;
        destroyTodoSortable();
        todoListContainer.innerHTML = `
          <div class="todo-loading">
            <div class="todo-loading__spinner"></div>
            <div class="todo-loading__text">ƒêang t·∫£i danh s√°ch vi·ªác c·∫ßn l√†m c√πng nhau...</div>
          </div>
        `;
      }

      function attachTodoHandlers() {
        const checkboxes = document.querySelectorAll("[data-todo-checkbox]");
        checkboxes.forEach((checkbox) => {
          if (checkbox.dataset.todoHandlerBound === "true") {
            return;
          }

          checkbox.dataset.todoHandlerBound = "true";
          checkbox.addEventListener("change", async (e) => {
            const todoId = checkbox.dataset.todoCheckbox;
            if (!todoId || !firestore || !timelineFormUnlocked) {
              checkbox.checked = false;
              return;
            }

            const isChecked = checkbox.checked;

            // N·∫øu ƒëang uncheck (ƒë√£ completed), y√™u c·∫ßu x√°c nh·∫≠n
            if (!isChecked) {
              e.preventDefault();
              checkbox.checked = true; // gi·ªØ tr·∫°ng th√°i cho ƒë·∫øn khi x√°c nh·∫≠n
              openUncompleteModal(todoId);
              return;
            }

            // N·∫øu ƒëang check (ch∆∞a completed), m·ªü modal ƒë·ªÉ ch·ªçn ng√†y gi·ªù
            e.preventDefault();
            checkbox.checked = false; // T·∫°m th·ªùi kh√¥ng check
            openCompletionModal(todoId);
          });
        });

        const deleteButtons = document.querySelectorAll("[data-todo-delete]");
        deleteButtons.forEach((button) => {
          if (button.dataset.todoDeleteBound === "true") {
            return;
          }

          button.dataset.todoDeleteBound = "true";
          button.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const todoId = button.dataset.todoDelete;
            if (!todoId || !firestore || !timelineFormUnlocked) {
              return;
            }

            // M·ªü modal x√°c nh·∫≠n m·∫≠t kh·∫©u
            openDeletePasswordModal(todoId);
          });
        });
      }

      function subscribeToTodoCollection() {
        if (!firestore) {
          return;
        }

        if (typeof todoUnsubscribe === "function") {
          todoUnsubscribe();
        }

        // Hi·ªÉn th·ªã loading tr∆∞·ªõc khi c√≥ snapshot ƒë·∫ßu ti√™n
        renderTodoLoading();

        const collectionRef = firestore
          .collection(TODO_COLLECTION)
          .orderBy("createdAt", "desc");

        todoUnsubscribe = collectionRef.onSnapshot(
          (snapshot) => {
            const todos = snapshot.docs.map((doc) => {
              const data = doc.data();
              return {
                id: doc.id,
                text: data.text || "",
                completed: Boolean(data.completed),
                completedAt: data.completedAt,
                createdAt: data.createdAt,
                updatedAt: data.updatedAt,
                order: typeof data.order === "number" ? data.order : null,
              };
            });

            renderTodoList(todos);
          },
          (error) => {
            console.error(error);
            renderTodoList([]);
          }
        );
      }

      function setTodoFormEnabled(isEnabled) {
        const todoForm = document.getElementById("todoForm");
        if (!todoForm) {
          return;
        }

        const enableForm = Boolean(isEnabled && timelineFormUnlocked);
        const elements = todoForm.querySelectorAll("input, button");
        elements.forEach((element) => {
          element.disabled = !enableForm;
        });

        todoForm.classList.toggle("todo-form--disabled", !enableForm);
      }

      function setTodoFormStatus(message, type = "info") {
        const status = document.getElementById("todoFormStatus");
        if (!status) {
          return;
        }

        status.textContent = message || "";
        const statusTypes = ["info", "success", "warning", "error", "pending"];
        statusTypes.forEach((statusType) => {
          status.classList.toggle(`todo-form__status--${statusType}`, statusType === type);
        });
      }

      async function handleTodoSubmit(event) {
        event.preventDefault();

        if (!timelineFormUnlocked) {
          setTodoFormStatus("Em c·∫ßn m·ªü kh√≥a b·∫±ng m·∫≠t kh·∫©u tr∆∞·ªõc khi th√™m vi·ªác c·∫ßn l√†m nha bae üíñ", "warning");
          return;
        }

        if (!firestore) {
          setTodoFormStatus("Ch·ª©c nƒÉng th√™m vi·ªác c·∫ßn l√†m ƒëang ƒë∆∞·ª£c thi·∫øt l·∫≠p. Vui l√≤ng quay l·∫°i sau nh√©!", "warning");
          return;
        }

        const todoForm = document.getElementById("todoForm");
        const todoTextInput = document.getElementById("todoTextInput");
        if (!todoForm || !todoTextInput) {
          return;
        }

        const todoText = (todoTextInput.value || "").trim();
        if (!todoText) {
          setTodoFormStatus("Vui l√≤ng nh·∫≠p n·ªôi dung vi·ªác c·∫ßn l√†m.", "warning");
          return;
        }

        const submitButton = document.getElementById("todoSubmitButton");
        try {
          if (submitButton) {
            setButtonLoading(submitButton, true, "ƒêang th√™m...");
          }
          setTodoFormStatus("ƒêang th√™m vi·ªác c·∫ßn l√†m...", "pending");

          await firestore.collection(TODO_COLLECTION).add({
            text: todoText,
            completed: false,
            order: -Date.now(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          });

          todoForm.reset();
          setTodoFormStatus("ƒê√£ th√™m vi·ªác c·∫ßn l√†m th√†nh c√¥ng! üíï", "success");

          setTimeout(() => {
            setTodoFormStatus("");
          }, 2000);
        } catch (error) {
          console.error(error);
          setTodoFormStatus(`Kh√¥ng th·ªÉ th√™m vi·ªác c·∫ßn l√†m: ${error?.message || String(error)}`, "error");
        } finally {
          if (submitButton) {
            setButtonLoading(submitButton, false);
          }
        }
      }

      function openCompletionModal(todoId) {
        const modal = document.getElementById("todoCompletionModal");
        const dateInput = document.getElementById("completionDateInput");
        const timeInput = document.getElementById("completionTimeInput");
        
        if (!modal || !dateInput || !timeInput) {
          return;
        }

        currentTodoIdForCompletion = todoId;

        // Set default values to current date and time
        const now = new Date();
        const dateStr = now.toISOString().split("T")[0];
        const timeStr = `${String(now.getHours()).padStart(2, "0")}:${String(now.getMinutes()).padStart(2, "0")}`;

        dateInput.value = dateStr;
        timeInput.value = timeStr;

        modal.hidden = false;
        document.body.classList.add("todo-completion-modal-open");
        dateInput.focus();
      }

      function closeCompletionModal() {
        const modal = document.getElementById("todoCompletionModal");
        if (!modal) {
          return;
        }

        modal.hidden = true;
        document.body.classList.remove("todo-completion-modal-open");
        currentTodoIdForCompletion = null;
      }

      async function handleCompletionSubmit(event) {
        event.preventDefault();

        if (!currentTodoIdForCompletion || !firestore) {
          return;
        }

        const dateInput = document.getElementById("completionDateInput");
        const timeInput = document.getElementById("completionTimeInput");
        const submitButton = document.getElementById("completionSubmitButton");

        if (!dateInput || !timeInput) {
          return;
        }

        const dateValue = dateInput.value;
        const timeValue = timeInput.value;

        if (!dateValue || !timeValue) {
          alert("Vui l√≤ng ch·ªçn ƒë·∫ßy ƒë·ªß ng√†y v√† gi·ªù ho√†n th√†nh.");
          return;
        }

        try {
          if (submitButton) {
            setButtonLoading(submitButton, true, "ƒêang l∆∞u...");
          }
          // Combine date and time
          const [year, month, day] = dateValue.split("-");
          const [hours, minutes] = timeValue.split(":");
          const completedDate = new Date(year, month - 1, day, hours, minutes);

          await firestore.collection(TODO_COLLECTION).doc(currentTodoIdForCompletion).update({
            completed: true,
            completedAt: firebase.firestore.Timestamp.fromDate(completedDate),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          });

          closeCompletionModal();
        } catch (error) {
          console.error(error);
          alert(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t: ${error?.message || String(error)}`);
        } finally {
          if (submitButton) {
            setButtonLoading(submitButton, false);
          }
        }
      }

      function openDeletePasswordModal(todoId) {
        const modal = document.getElementById("todoDeletePasswordModal");
        const passwordInput = document.getElementById("deletePasswordInput");
        
        if (!modal || !passwordInput) {
          return;
        }

        currentTodoIdForDelete = todoId;

        // Reset form
        const form = document.getElementById("todoDeletePasswordForm");
        if (form) {
          form.reset();
        }
        setDeletePasswordStatus("", "info");

        modal.hidden = false;
        document.body.classList.add("todo-delete-password-modal-open");
        passwordInput.focus();
      }

      function closeDeletePasswordModal() {
        const modal = document.getElementById("todoDeletePasswordModal");
        if (!modal) {
          return;
        }

        modal.hidden = true;
        document.body.classList.remove("todo-delete-password-modal-open");
        currentTodoIdForDelete = null;

        // Reset form
        const form = document.getElementById("todoDeletePasswordForm");
        const passwordInput = document.getElementById("deletePasswordInput");
        if (form) {
          form.reset();
        }
        if (passwordInput) {
          passwordInput.value = "";
        }
        setDeletePasswordStatus("", "info");
      }

      function setDeletePasswordStatus(message, type = "info") {
        const status = document.getElementById("deletePasswordStatus");
        if (!status) {
          return;
        }

        status.textContent = message || "";
        const statusTypes = ["info", "success", "warning", "error", "pending"];
        statusTypes.forEach((statusType) => {
          status.classList.toggle(`todo-delete-password-modal__status--${statusType}`, statusType === type);
        });
      }

      async function handleDeletePasswordSubmit(event) {
        event.preventDefault();

        if (!currentTodoIdForDelete || !firestore) {
          return;
        }

        const passwordInput = document.getElementById("deletePasswordInput");
        const submitButton = document.getElementById("deletePasswordSubmitButton");

        if (!passwordInput) {
          return;
        }

        const submittedPassword = passwordInput.value.trim();

        if (submittedPassword !== TIMELINE_FORM_PASSWORD) {
          setDeletePasswordStatus("Sai m·∫≠t kh·∫©u r·ªìi, th·ª≠ l·∫°i nh√© üíî", "error");
          passwordInput.value = "";
          passwordInput.focus();
          return;
        }

        try {
          if (submitButton) {
            submitButton.disabled = true;
          }

          setDeletePasswordStatus("ƒêang x√≥a...", "pending");

          await firestore.collection(TODO_COLLECTION).doc(currentTodoIdForDelete).delete();

          closeDeletePasswordModal();
        } catch (error) {
          console.error(error);
          setDeletePasswordStatus(`Kh√¥ng th·ªÉ x√≥a: ${error?.message || String(error)}`, "error");
        } finally {
          if (submitButton) {
            submitButton.disabled = false;
          }
        }
      }

      function checkUnlockStatus() {
        // Ki·ªÉm tra localStorage ƒë·ªÉ xem ƒë√£ unlock ch∆∞a
        const unlocked = localStorage.getItem("timelineFormUnlocked");
        if (unlocked === "true") {
          timelineFormUnlocked = true;
          setTodoFormEnabled(true);
          setTodoFormStatus("", "info");
          updateTodoSortableDisabled();
        } else {
          timelineFormUnlocked = false;
          setTodoFormEnabled(false);
          setTodoFormStatus("Vui l√≤ng quay l·∫°i trang ch√≠nh v√† nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y.", "warning");
          updateTodoSortableDisabled();
        }
      }

      function initFirebase() {
        if (!window.firebase || !window.FIREBASE_CONFIG) {
          setTodoFormStatus("Firebase ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh.", "error");
          return;
        }

        try {
          if (!firebase.apps.length) {
            firebase.initializeApp(window.FIREBASE_CONFIG);
          }
          firestore = firebase.firestore();
          isFirebaseReady = true;
          
          checkUnlockStatus();
          // Hi·ªÉn th·ªã loading ngay khi kh·ªüi t·∫°o
          renderTodoLoading();
          subscribeToTodoCollection();
        } catch (error) {
          console.error(error);
          setTodoFormStatus("Kh√¥ng th·ªÉ kh·ªüi t·∫°o Firebase.", "error");
        }
      }

      const todoForm = document.getElementById("todoForm");
      if (todoForm) {
        todoForm.addEventListener("submit", handleTodoSubmit);
      }

      const todoSubmitButton = document.getElementById("todoSubmitButton");
      const completionSubmitButton = document.getElementById("completionSubmitButton");
      const deletePasswordSubmitButton = document.getElementById("deletePasswordSubmitButton");
      attachButtonFeedback(todoSubmitButton);
      attachButtonFeedback(completionSubmitButton);
      attachButtonFeedback(deletePasswordSubmitButton);

      const completionModal = document.getElementById("todoCompletionModal");
      const completionForm = document.getElementById("todoCompletionForm");
      
      if (completionModal) {
        completionModal.addEventListener("click", (event) => {
          const target = event.target;
          if (target && "completionModalClose" in target.dataset) {
            closeCompletionModal();
          }
        });
      }

      if (completionForm) {
        completionForm.addEventListener("submit", handleCompletionSubmit);
      }

      // Uncomplete modal bindings
      const uncompleteModal = document.getElementById("todoUncompleteModal");
      const uncompleteConfirmButton = document.getElementById("uncompleteSubmitButton");
      attachButtonFeedback(uncompleteConfirmButton);
      if (uncompleteModal) {
        uncompleteModal.addEventListener("click", (event) => {
          const target = event.target;
          if (target && "uncompleteModalClose" in target.dataset) {
            closeUncompleteModal();
          }
        });
      }
      if (uncompleteConfirmButton) {
        uncompleteConfirmButton.addEventListener("click", handleUncompleteConfirm);
      }

      const deletePasswordModal = document.getElementById("todoDeletePasswordModal");
      const deletePasswordForm = document.getElementById("todoDeletePasswordForm");
      
      if (deletePasswordModal) {
        deletePasswordModal.addEventListener("click", (event) => {
          const target = event.target;
          if (target && "deletePasswordModalClose" in target.dataset) {
            closeDeletePasswordModal();
          }
        });
      }

      if (deletePasswordForm) {
        deletePasswordForm.addEventListener("submit", handleDeletePasswordSubmit);
      }

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          const deleteModal = document.getElementById("todoDeletePasswordModal");
          if (deleteModal && !deleteModal.hidden) {
            closeDeletePasswordModal();
            return;
          }
          const uncompleteModalEl = document.getElementById("todoUncompleteModal");
          if (uncompleteModalEl && !uncompleteModalEl.hidden) {
            closeUncompleteModal();
            return;
          }
          const completionModal = document.getElementById("todoCompletionModal");
          if (completionModal && !completionModal.hidden) {
            closeCompletionModal();
          }
        }
      });

      initFirebase();

      window.addEventListener("unload", () => {
        if (typeof todoUnsubscribe === "function") {
          todoUnsubscribe();
        }
      });
    </script>
  </body>
</html>

